module GitTemplate
  module Generators
    class Base
      # explicitly set
      attr_reader :golden_text
      
      #inferred from context
      attr_reader :repo, :repo_path, :metadata
      
      def self.golden_text(text = nil)
        if text
          @golden_text = text
        else
          @golden_text
        end
      end
      
      def self.generate(config)
        new(config).generate
      end
      
      def initialize(config)
        @config = config
        @golden_text = self.class.golden_text
        @metadata = build_metadata
      end
      
      def generate
        raise NotImplementedError, "Subclasses must implement #generate"
      end
      
      protected
      
      def build_metadata
        {
          generator: self.class.name,
          generated_at: Time.now.strftime('%Y-%m-%d %H:%M:%S'),
          config_id: @config.respond_to?(:id) ? @config.id : nil,
          source_file: caller_locations(2, 1).first&.path,
          source_line: caller_locations(2, 1).first&.lineno,
          git: build_git_metadata
        }
      end
      
      def metadata_comment(prefix: '#')
        lines = [
          "#{prefix} Generated by: #{metadata[:generator]}",
          "#{prefix} Generated at: #{metadata[:generated_at]}"
        ]
        
        if metadata[:config_id]
          lines << "#{prefix} Config ID: #{metadata[:config_id]}"
        end
        
        if metadata[:source_file]
          lines << "#{prefix} Source: #{metadata[:source_file]}:#{metadata[:source_line]}"
        end
        
        # Add git information
        if metadata[:git]
          git_info = metadata[:git]
          if git_info[:commit]
            lines << "#{prefix} Git commit: #{git_info[:commit]}"
          end
          if git_info[:branch]
            lines << "#{prefix} Git branch: #{git_info[:branch]}"
          end
          if git_info[:status] && !git_info[:status].empty?
            lines << "#{prefix} Git status: #{git_info[:status]}"
          end
          if git_info[:remote]
            lines << "#{prefix} Git remote: #{git_info[:remote]}"
          end
        end
        
        lines.join("\n")
      end
      
      private
      
      def build_git_metadata
        git_info = {}
        
        begin
          # Get current commit hash
          commit = `git rev-parse HEAD 2>/dev/null`.strip
          git_info[:commit] = commit unless commit.empty?
          
          # Get current branch
          branch = `git rev-parse --abbrev-ref HEAD 2>/dev/null`.strip
          git_info[:branch] = branch unless branch.empty?
          
          # Get repository status (check if there are uncommitted changes)
          status_output = `git status --porcelain 2>/dev/null`.strip
          if !status_output.empty?
            git_info[:status] = "dirty (#{status_output.lines.count} changes)"
          else
            git_info[:status] = "clean"
          end
          
          # Get remote URL if available
          remote_url = `git config --get remote.origin.url 2>/dev/null`.strip
          git_info[:remote] = remote_url unless remote_url.empty?
          
        rescue => e
          # If git commands fail, just return empty hash
          git_info[:error] = "Git info unavailable: #{e.message}"
        end
        
        git_info
      end
    end
  end
end